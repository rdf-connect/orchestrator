// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.0
// source: intermediate.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

export const protobufPackage = "rdfc";

/**
 * A RDFC channel reader.
 * Note that this is a declarative type, and must be instantiated by the runner.
 */
export interface Reader {
  /** Channel URI. */
  uri: string;
}

/**
 * A RDFC channel writer.
 * Note that this is a declarative type, and must be instantiated by the runner.
 */
export interface Writer {
  /** Channel URI. */
  uri: string;
}

/** Either a single argument, or a nested */
export interface ArgumentLiteral {
  /** Raw bytes. */
  bytes?: Uint8Array | undefined;
  /** UTF-8 encoded bytes. */
  string?: string | undefined;
  /** Simple booleans. */
  bool?: boolean | undefined;
  /** Floating point numbers. */
  double?: number | undefined;
  float?: number | undefined;
  /** Integer types. */
  int32?: number | undefined;
  int64?: number | undefined;
  uint32?: number | undefined;
  uint64?: number | undefined;
  /** Date representation using nanosecond accuracy. */
  timestamp?: Date | undefined;
  /** RDFC channel implementations. */
  reader?: Reader | undefined;
  writer?: Writer | undefined;
}

export interface ArgumentLiteral_List {
  values: ArgumentLiteral[];
}

export interface ArgumentMap {
  values: { [key: string]: Argument };
}

export interface ArgumentMap_ValuesEntry {
  key: string;
  value: Argument | undefined;
}

export interface ArgumentMap_List {
  values: ArgumentMap[];
}

/** An argument is either a literal or a map, or a list of literals or a list of maps. */
export interface Argument {
  literal?: ArgumentLiteral | undefined;
  literals?: ArgumentLiteral_List | undefined;
  map?: ArgumentMap | undefined;
  maps?: ArgumentMap_List | undefined;
}

/** A processor declaration. */
export interface Processor {
  /** The URI of the processor. */
  uri: string;
  /** The source code entrypoint. */
  entrypoint: string;
  /** Additional metadata, as required by the runners. */
  metadata: { [key: string]: string };
}

export interface Processor_MetadataEntry {
  key: string;
  value: string;
}

/** A concrete stage of a given processor, with instantiated arguments. */
export interface Stage {
  /** The URI of the stage. */
  uri: string;
  /** The processor definition. */
  processor: Processor | undefined;
  /** Stage arguments. */
  arguments: { [key: string]: Argument };
}

export interface Stage_ArgumentsEntry {
  key: string;
  value: Argument | undefined;
}

function createBaseReader(): Reader {
  return { uri: "" };
}

export const Reader = {
  encode(
    message: Reader,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reader {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reader {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Reader): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reader>, I>>(base?: I): Reader {
    return Reader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reader>, I>>(object: I): Reader {
    const message = createBaseReader();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseWriter(): Writer {
  return { uri: "" };
}

export const Writer = {
  encode(
    message: Writer,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Writer {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Writer {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Writer): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Writer>, I>>(base?: I): Writer {
    return Writer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Writer>, I>>(object: I): Writer {
    const message = createBaseWriter();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseArgumentLiteral(): ArgumentLiteral {
  return {
    bytes: undefined,
    string: undefined,
    bool: undefined,
    double: undefined,
    float: undefined,
    int32: undefined,
    int64: undefined,
    uint32: undefined,
    uint64: undefined,
    timestamp: undefined,
    reader: undefined,
    writer: undefined,
  };
}

export const ArgumentLiteral = {
  encode(
    message: ArgumentLiteral,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.bytes !== undefined) {
      writer.uint32(82).bytes(message.bytes);
    }
    if (message.string !== undefined) {
      writer.uint32(162).string(message.string);
    }
    if (message.bool !== undefined) {
      writer.uint32(240).bool(message.bool);
    }
    if (message.double !== undefined) {
      writer.uint32(321).double(message.double);
    }
    if (message.float !== undefined) {
      writer.uint32(341).float(message.float);
    }
    if (message.int32 !== undefined) {
      writer.uint32(400).int32(message.int32);
    }
    if (message.int64 !== undefined) {
      writer.uint32(416).int64(message.int64);
    }
    if (message.uint32 !== undefined) {
      writer.uint32(432).uint32(message.uint32);
    }
    if (message.uint64 !== undefined) {
      writer.uint32(448).uint64(message.uint64);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(
        toTimestamp(message.timestamp),
        writer.uint32(482).fork(),
      ).ldelim();
    }
    if (message.reader !== undefined) {
      Reader.encode(message.reader, writer.uint32(562).fork()).ldelim();
    }
    if (message.writer !== undefined) {
      Writer.encode(message.writer, writer.uint32(578).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArgumentLiteral {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgumentLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.string = reader.string();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.bool = reader.bool();
          continue;
        case 40:
          if (tag !== 321) {
            break;
          }

          message.double = reader.double();
          continue;
        case 42:
          if (tag !== 341) {
            break;
          }

          message.float = reader.float();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.int32 = reader.int32();
          continue;
        case 52:
          if (tag !== 416) {
            break;
          }

          message.int64 = longToNumber(reader.int64() as Long);
          continue;
        case 54:
          if (tag !== 432) {
            break;
          }

          message.uint32 = reader.uint32();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.uint64 = longToNumber(reader.uint64() as Long);
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.timestamp = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }

          message.reader = Reader.decode(reader, reader.uint32());
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }

          message.writer = Writer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgumentLiteral {
    return {
      bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : undefined,
      string: isSet(object.string)
        ? globalThis.String(object.string)
        : undefined,
      bool: isSet(object.bool) ? globalThis.Boolean(object.bool) : undefined,
      double: isSet(object.double)
        ? globalThis.Number(object.double)
        : undefined,
      float: isSet(object.float) ? globalThis.Number(object.float) : undefined,
      int32: isSet(object.int32) ? globalThis.Number(object.int32) : undefined,
      int64: isSet(object.int64) ? globalThis.Number(object.int64) : undefined,
      uint32: isSet(object.uint32)
        ? globalThis.Number(object.uint32)
        : undefined,
      uint64: isSet(object.uint64)
        ? globalThis.Number(object.uint64)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? fromJsonTimestamp(object.timestamp)
        : undefined,
      reader: isSet(object.reader) ? Reader.fromJSON(object.reader) : undefined,
      writer: isSet(object.writer) ? Writer.fromJSON(object.writer) : undefined,
    };
  },

  toJSON(message: ArgumentLiteral): unknown {
    const obj: any = {};
    if (message.bytes !== undefined) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    if (message.string !== undefined) {
      obj.string = message.string;
    }
    if (message.bool !== undefined) {
      obj.bool = message.bool;
    }
    if (message.double !== undefined) {
      obj.double = message.double;
    }
    if (message.float !== undefined) {
      obj.float = message.float;
    }
    if (message.int32 !== undefined) {
      obj.int32 = Math.round(message.int32);
    }
    if (message.int64 !== undefined) {
      obj.int64 = Math.round(message.int64);
    }
    if (message.uint32 !== undefined) {
      obj.uint32 = Math.round(message.uint32);
    }
    if (message.uint64 !== undefined) {
      obj.uint64 = Math.round(message.uint64);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.reader !== undefined) {
      obj.reader = Reader.toJSON(message.reader);
    }
    if (message.writer !== undefined) {
      obj.writer = Writer.toJSON(message.writer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgumentLiteral>, I>>(
    base?: I,
  ): ArgumentLiteral {
    return ArgumentLiteral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgumentLiteral>, I>>(
    object: I,
  ): ArgumentLiteral {
    const message = createBaseArgumentLiteral();
    message.bytes = object.bytes ?? undefined;
    message.string = object.string ?? undefined;
    message.bool = object.bool ?? undefined;
    message.double = object.double ?? undefined;
    message.float = object.float ?? undefined;
    message.int32 = object.int32 ?? undefined;
    message.int64 = object.int64 ?? undefined;
    message.uint32 = object.uint32 ?? undefined;
    message.uint64 = object.uint64 ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.reader =
      object.reader !== undefined && object.reader !== null
        ? Reader.fromPartial(object.reader)
        : undefined;
    message.writer =
      object.writer !== undefined && object.writer !== null
        ? Writer.fromPartial(object.writer)
        : undefined;
    return message;
  },
};

function createBaseArgumentLiteral_List(): ArgumentLiteral_List {
  return { values: [] };
}

export const ArgumentLiteral_List = {
  encode(
    message: ArgumentLiteral_List,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.values) {
      ArgumentLiteral.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ArgumentLiteral_List {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgumentLiteral_List();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(ArgumentLiteral.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgumentLiteral_List {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => ArgumentLiteral.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ArgumentLiteral_List): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => ArgumentLiteral.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgumentLiteral_List>, I>>(
    base?: I,
  ): ArgumentLiteral_List {
    return ArgumentLiteral_List.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgumentLiteral_List>, I>>(
    object: I,
  ): ArgumentLiteral_List {
    const message = createBaseArgumentLiteral_List();
    message.values =
      object.values?.map((e) => ArgumentLiteral.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArgumentMap(): ArgumentMap {
  return { values: {} };
}

export const ArgumentMap = {
  encode(
    message: ArgumentMap,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    Object.entries(message.values).forEach(([key, value]) => {
      ArgumentMap_ValuesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArgumentMap {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgumentMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ArgumentMap_ValuesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgumentMap {
    return {
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Argument }>(
            (acc, [key, value]) => {
              acc[key] = Argument.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: ArgumentMap): unknown {
    const obj: any = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = Argument.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgumentMap>, I>>(base?: I): ArgumentMap {
    return ArgumentMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgumentMap>, I>>(
    object: I,
  ): ArgumentMap {
    const message = createBaseArgumentMap();
    message.values = Object.entries(object.values ?? {}).reduce<{
      [key: string]: Argument;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Argument.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseArgumentMap_ValuesEntry(): ArgumentMap_ValuesEntry {
  return { key: "", value: undefined };
}

export const ArgumentMap_ValuesEntry = {
  encode(
    message: ArgumentMap_ValuesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Argument.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ArgumentMap_ValuesEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgumentMap_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Argument.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgumentMap_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Argument.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ArgumentMap_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Argument.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgumentMap_ValuesEntry>, I>>(
    base?: I,
  ): ArgumentMap_ValuesEntry {
    return ArgumentMap_ValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgumentMap_ValuesEntry>, I>>(
    object: I,
  ): ArgumentMap_ValuesEntry {
    const message = createBaseArgumentMap_ValuesEntry();
    message.key = object.key ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? Argument.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseArgumentMap_List(): ArgumentMap_List {
  return { values: [] };
}

export const ArgumentMap_List = {
  encode(
    message: ArgumentMap_List,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.values) {
      ArgumentMap.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArgumentMap_List {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgumentMap_List();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(ArgumentMap.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgumentMap_List {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => ArgumentMap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ArgumentMap_List): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => ArgumentMap.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgumentMap_List>, I>>(
    base?: I,
  ): ArgumentMap_List {
    return ArgumentMap_List.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgumentMap_List>, I>>(
    object: I,
  ): ArgumentMap_List {
    const message = createBaseArgumentMap_List();
    message.values =
      object.values?.map((e) => ArgumentMap.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArgument(): Argument {
  return {
    literal: undefined,
    literals: undefined,
    map: undefined,
    maps: undefined,
  };
}

export const Argument = {
  encode(
    message: Argument,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.literal !== undefined) {
      ArgumentLiteral.encode(
        message.literal,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.literals !== undefined) {
      ArgumentLiteral_List.encode(
        message.literals,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.map !== undefined) {
      ArgumentMap.encode(message.map, writer.uint32(26).fork()).ldelim();
    }
    if (message.maps !== undefined) {
      ArgumentMap_List.encode(message.maps, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Argument {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.literal = ArgumentLiteral.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.literals = ArgumentLiteral_List.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.map = ArgumentMap.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maps = ArgumentMap_List.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Argument {
    return {
      literal: isSet(object.literal)
        ? ArgumentLiteral.fromJSON(object.literal)
        : undefined,
      literals: isSet(object.literals)
        ? ArgumentLiteral_List.fromJSON(object.literals)
        : undefined,
      map: isSet(object.map) ? ArgumentMap.fromJSON(object.map) : undefined,
      maps: isSet(object.maps)
        ? ArgumentMap_List.fromJSON(object.maps)
        : undefined,
    };
  },

  toJSON(message: Argument): unknown {
    const obj: any = {};
    if (message.literal !== undefined) {
      obj.literal = ArgumentLiteral.toJSON(message.literal);
    }
    if (message.literals !== undefined) {
      obj.literals = ArgumentLiteral_List.toJSON(message.literals);
    }
    if (message.map !== undefined) {
      obj.map = ArgumentMap.toJSON(message.map);
    }
    if (message.maps !== undefined) {
      obj.maps = ArgumentMap_List.toJSON(message.maps);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Argument>, I>>(base?: I): Argument {
    return Argument.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Argument>, I>>(object: I): Argument {
    const message = createBaseArgument();
    message.literal =
      object.literal !== undefined && object.literal !== null
        ? ArgumentLiteral.fromPartial(object.literal)
        : undefined;
    message.literals =
      object.literals !== undefined && object.literals !== null
        ? ArgumentLiteral_List.fromPartial(object.literals)
        : undefined;
    message.map =
      object.map !== undefined && object.map !== null
        ? ArgumentMap.fromPartial(object.map)
        : undefined;
    message.maps =
      object.maps !== undefined && object.maps !== null
        ? ArgumentMap_List.fromPartial(object.maps)
        : undefined;
    return message;
  },
};

function createBaseProcessor(): Processor {
  return { uri: "", entrypoint: "", metadata: {} };
}

export const Processor = {
  encode(
    message: Processor,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.entrypoint !== "") {
      writer.uint32(18).string(message.entrypoint);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Processor_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Processor {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entrypoint = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Processor_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      entrypoint: isSet(object.entrypoint)
        ? globalThis.String(object.entrypoint)
        : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: Processor): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processor>, I>>(base?: I): Processor {
    return Processor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processor>, I>>(
    object: I,
  ): Processor {
    const message = createBaseProcessor();
    message.uri = object.uri ?? "";
    message.entrypoint = object.entrypoint ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseProcessor_MetadataEntry(): Processor_MetadataEntry {
  return { key: "", value: "" };
}

export const Processor_MetadataEntry = {
  encode(
    message: Processor_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): Processor_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Processor_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processor_MetadataEntry>, I>>(
    base?: I,
  ): Processor_MetadataEntry {
    return Processor_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processor_MetadataEntry>, I>>(
    object: I,
  ): Processor_MetadataEntry {
    const message = createBaseProcessor_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStage(): Stage {
  return { uri: "", processor: undefined, arguments: {} };
}

export const Stage = {
  encode(message: Stage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.processor !== undefined) {
      Processor.encode(message.processor, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.arguments).forEach(([key, value]) => {
      Stage_ArgumentsEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Stage {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.processor = Processor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Stage_ArgumentsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.arguments[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stage {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      processor: isSet(object.processor)
        ? Processor.fromJSON(object.processor)
        : undefined,
      arguments: isObject(object.arguments)
        ? Object.entries(object.arguments).reduce<{ [key: string]: Argument }>(
            (acc, [key, value]) => {
              acc[key] = Argument.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: Stage): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.processor !== undefined) {
      obj.processor = Processor.toJSON(message.processor);
    }
    if (message.arguments) {
      const entries = Object.entries(message.arguments);
      if (entries.length > 0) {
        obj.arguments = {};
        entries.forEach(([k, v]) => {
          obj.arguments[k] = Argument.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stage>, I>>(base?: I): Stage {
    return Stage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stage>, I>>(object: I): Stage {
    const message = createBaseStage();
    message.uri = object.uri ?? "";
    message.processor =
      object.processor !== undefined && object.processor !== null
        ? Processor.fromPartial(object.processor)
        : undefined;
    message.arguments = Object.entries(object.arguments ?? {}).reduce<{
      [key: string]: Argument;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Argument.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseStage_ArgumentsEntry(): Stage_ArgumentsEntry {
  return { key: "", value: undefined };
}

export const Stage_ArgumentsEntry = {
  encode(
    message: Stage_ArgumentsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Argument.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): Stage_ArgumentsEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStage_ArgumentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Argument.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stage_ArgumentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Argument.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Stage_ArgumentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Argument.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stage_ArgumentsEntry>, I>>(
    base?: I,
  ): Stage_ArgumentsEntry {
    return Stage_ArgumentsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stage_ArgumentsEntry>, I>>(
    object: I,
  ): Stage_ArgumentsEntry {
    const message = createBaseStage_ArgumentsEntry();
    message.key = object.key ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? Argument.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
