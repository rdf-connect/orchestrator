import { JVMRunnerError } from "../error";

export class Processor {
  /*
   * A map of all processor definitions, automatically generated by the
   * Definition decorator.
   */
  private static definitions = new Map<string, Function>();

  /*
   * Retrieve a processor definition by its resource name.
   */
  private args: Map<string, unknown>;

  /* Parse the incoming arguments. */
  constructor(args: Map<string, unknown>) {
    this.args = args;
  }

  /* The actual implementation of the processor must be overridden here. */
  public exec(): void {
    throw JVMRunnerError.missingImplementation();
  }

  /* Retrieve an argument. */
  public getArgument<T>(key: string): T {
    const result = this.args.get(key);

    if (!result) {
      throw JVMRunnerError.missingArgument(key);
    }

    return result as T;
  }

  /* Retrieve an optional argument. */
  public getOptionalArgument<T>(key: string): T | null {
    return (this.args.get(key) ?? null) as T | null;
  }

  /* Register a processor definition. */
  public static register(resource: string, processor: Function) {
    Processor.definitions.set(resource, processor);
  }

  /* Return all declared processors mapped to their name. */
  public static getProcessors(): Map<string, unknown> {
    return new Map(Processor.definitions);
  }
}
